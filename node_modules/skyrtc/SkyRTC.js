var WebSocketServer = require('ws').Server;
var UUID = require('node-uuid');
var events = require('events');
var util = require('util');
var errorCb = function(rtc) {
	return function(error) {
		if (error) {
			rtc.emit("error", error);
		}
	};
};

function SkyRTC() {
	this.sockets = [];
	this.rooms = {};
	/*有新的客户端加入会触发的事件*/
	this.on('__join', function(data, socket) {
		//console.log("socket:  " + socket.object);
		//console.log("socket length:  " + this.sockets.length);
		var ids = [],
			i, m,
			room = data.room || "__default", //房间名字为自定义，如果没有自定义，则设置为默认__default
			curSocket,
			curRoom;
		//注意javascript中对象引用的问题，对于变量而言，所有的引用都是指针地址的指向，所以这里修改curRoom后的变化是直接修改rooms的值的
		curRoom = this.rooms[room] = this.rooms[room] || [];

		for (i = 0, m = curRoom.length; i < m; i++) {
			curSocket = curRoom[i];
			if (curSocket.id === socket.id) { /** 对所有的已经存在的socket id号与当前客户端的socket句柄进行匹配
			 									* 如果是相同的，则证明是同一个房间，继续匹配其他房间*/
				continue;
			}
			ids.push(curSocket.id);  //把所有其他房间的id号放入ids数组中
			curSocket.send(JSON.stringify({  /** 发送新的点对点信号，对应的参数是该新加入的客户端id；
											  *  这里的发送者是从服务器上获取的其他的每一个socket句柄*/
				"eventName": "_new_peer",
				"data": {
					"socketId": socket.id
				}
			}), errorCb);
		}

		curRoom.push(socket);  //注意和for循环的顺序
		socket.room = room;    //给socket发配room标签
		for(i=0; i<this.rooms[room].length; i++) {
			console.log("这是通过rooms打印出来的房间id号: " + this.rooms[room][i].id);
		}
		socket.send(JSON.stringify({
			"eventName": "_peers",   //这个信号的发送，是一切的开始
			"data": {
				"connections": ids,
				"you": socket.id
			}
		}), errorCb);

		this.emit('new_peer', socket, room);
	});

	this.on('__ice_candidate', function(data, socket) {
		var soc = this.getSocket(data.socketId);

		if (soc) {
			soc.send(JSON.stringify({
				"eventName": "_ice_candidate",
				"data": {
					"label": data.label,
					"candidate": data.candidate,
					"socketId": socket.id
				}
			}), errorCb);

			this.emit('ice_candidate', socket, data);
		}
	});

	this.on('__offer', function(data, socket) {
		var soc = this.getSocket(data.socketId);

		if (soc) {
			soc.send(JSON.stringify({
				"eventName": "_offer",
				"data": {
					"sdp": data.sdp,
					"socketId": socket.id
				}
			}), errorCb);
		}
		this.emit('offer', socket, data);
	});

	this.on('__answer', function(data, socket) {
		var soc = this.getSocket(data.socketId);
		if (soc) {
			soc.send(JSON.stringify({
				"eventName": "_answer",
				"data": {
					"sdp": data.sdp,
					"socketId": socket.id
				}
			}), errorCb);
			this.emit('answer', socket, data);
		}
	});
}

/*util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。
* JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。
* */
util.inherits(SkyRTC, events.EventEmitter);

SkyRTC.prototype.addSocket = function(socket) {
	this.sockets.push(socket);
};

SkyRTC.prototype.removeSocket = function(socket) {
	var i = this.sockets.indexOf(socket),
		room = socket.room;
	this.sockets.splice(i, 1);
	if (room) {
		i = this.rooms[room].indexOf(socket);
		this.rooms[room].splice(i, 1);
		if (this.rooms[room].length === 0) {
			delete this.rooms[room];
		}
	}
};

SkyRTC.prototype.broadcast = function(data, errorCb) {
	var i;
	for (i = this.sockets.length; i--;) {
		this.sockets[i].send(data, errorCb);
	}
};

SkyRTC.prototype.broadcastInRoom = function(room, data, errorCb) {
	var curRoom = this.rooms[room],
		i;
	if (curRoom) {
		for (i = curRoom.length; i--;) {
			curRoom[i].send(data, errorCb);
		}
	}
};

SkyRTC.prototype.getRooms = function() {
	var rooms = [],
		room;
	for (room in this.rooms) {
		rooms.push(room);
	}
	return rooms;
};
/*通过客户端传入的socketid检测存在的socket实例，并返回socket实例*/
SkyRTC.prototype.getSocket = function(id) {
	var i,
		curSocket;
	if (!this.sockets) {
		return;
	}
	for (i = this.sockets.length; i--;) {
		curSocket = this.sockets[i];
		console.log("socket length: " + i);
		if (id === curSocket.id) {
			return curSocket;
		}
	}
	return;
};

SkyRTC.prototype.init = function(socket) {
	var that = this;

	/** 在nodejs中用node-uuid生成一个id号；其中
	 * uuid.v1  Generate and return a RFC4122 v1 (timestamp-based) UUID.
	 * uuid.v4  Generate and return a RFC4122 v4 (random) UUID.		*/
	socket.id = UUID.v4();

	/*将新建的socket push 到服务器的sockets[]数组中，保存当前的客户端socket实例*/
	that.addSocket(socket);

	//为新连接绑定事件处理器   fffff emit发送事件
	socket.on('message', function(data) {
		var json = JSON.parse(data);
		/*对客户端发送过来的事件进行处理，emit发送通知*/
		if (json.eventName) {
			that.emit(json.eventName, json.data, socket);
		} else {
			that.emit("socket_message", socket, data); //当没有自定义事件的时候触发这个事件，可以设置为服务器的默认事件
		}
	});

	//连接关闭后从SkyRTC实例中移除连接，并通知其他连接
	socket.on('close', function() {
		var i, m,
			room = socket.room,
			curRoom;
		if (room) {
			curRoom = that.rooms[room];
			for (i = curRoom.length; i--;) {
				if (curRoom[i].id === socket.id) {
					continue;
				}
				curRoom[i].send(JSON.stringify({
					"eventName": "_remove_peer",
					"data": {
						"socketId": socket.id
					}
				}), errorCb);
			}
		}

		that.removeSocket(socket);

		that.emit('remove_peer', socket.id, that);
	});
	that.emit('new_connect', socket); /*新用户建立连接后触发*/
};

module.exports.listen = function(server) {
	var SkyRTCServer;
	if (typeof server === 'number') {
		SkyRTCServer = new WebSocketServer({
			port: server
		});
	} else {
		SkyRTCServer = new WebSocketServer({
			server: server
		});
	}

	SkyRTCServer.rtc = new SkyRTC();
	errorCb = errorCb(SkyRTCServer.rtc);
	/*监听connection的事件， 有新的客户端连接进来*/
	SkyRTCServer.on('connection', function(socket) {//socket是一个新的websocket操作实例
		this.rtc.init(socket);
	});

	return SkyRTCServer;
};//向SkyRTC-client相关事件绑定回调函数